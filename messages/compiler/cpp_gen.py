from exceptions import CmfParseError
import semantics


def is_int(type):
    return type in ['uint8', 'uint16', 'uint32', 'uint64', 'int8', 'int16', 'int32', 'int64']


def typestr(type):
    if not isinstance(type, dict):
        # A primitive type
        if is_int(type):
            return type + '_t'
        if type == 'string':
            return 'std::string'
        if type == 'bytes':
            return 'std::vector<uint8_t>'
        return type
    elif 'list' in type:
        return 'std::vector<' + typestr(type.list.type) + '>'
    elif 'kvpair' in type:
        return 'std::pair<' + typestr(type.kvpair.key) + ', ' + typestr(type.kvpair.value) + '>'
    elif 'map' in type:
        return 'std::map<' + typestr(type.map.key) + ', ' + typestr(type.map.value) + '>'
    elif 'optional' in type:
        return 'std::optional<' + typestr(type.optional.type) + '>'
    elif 'oneof' in type:
        return 'std::variant<' + ', '.join(type.oneof.msg_names) + '>'
    raise CmfParseError(type.parseinfo, "Invalid field type")


def structstr(msg):
    """ Take a msg AST node and create a string containing source of a C++ struct """
    struct = '''
struct {} {{
  static constexpr uint32_t id = {}; \n\n'''.format(msg.name, msg.id)
    for field in msg.fields:
        struct += "  " + typestr(field.type)
        struct += " {}; \n".format(field.name)

    struct += "};"
    return struct


def serializestr(msg):
    """
    Take a msg AST node and create a string containing a C++ serialization function for the given msg
    """

    s = '''
std::vector<uint8_t> serialize(const {}& t) {{
  std::vector<uint8_t> output;\n'''.format(msg.name)
    for field in msg.fields:
        s += '  cmf::Serialize(output, t.{});\n'.format(field.name)
    s += '  return output;\n}'
    return s


def file_header(namespace):
    header = '''


/***************************************
 Autogenerated by cmfc. Do not modify.
***************************************/

# include <cstdint>
# include <map>
# include <string>
# include <utility>
# include <variant>
# include <vector>

# include "serialize.h"

'''

    if namespace:
        header += 'namespace {} {{\n'.format(namespace)
    return header


def file_trailer(namespace):
    if namespace:
        return '\n}} // namespace {}\n'.format(namespace)
    return '\n'


def translate(ast, namespace=None):
    """ Walk concord message format (CMF) AST and generate C++ code """
    s = file_header(namespace)
    for msg in ast.msgs:
        s += structstr(msg) + '\n'
        s += serializestr(msg) + '\n'
    return s + file_trailer(namespace)
