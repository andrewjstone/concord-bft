#!/usr/bin/env python

import math
import os
import random
import sys
from pprint import pprint

sys.path.append("..")
import cppgen
import cmfc
from exceptions import CmfParseError

MAX_SIZE = 5
POSSIBLE_EMPTY_SIZES = [MAX_SIZE - i for i in range(0, math.ceil(MAX_SIZE / 2))]


def randint():
    return random.randint(0, 100)


def randstring():
    return '"' + random.choice(["a", "b", "c", "aa", "bb", "cc", "abcdef"]) + '"'


def byteExample():
    return "{0,1,2,3,4,5}"


def instanceName(msg_name, id):
    """Generate the name of an instance from a msg name"""
    return "_" + msg_name.lower() + str(id)


def test_name(msg_name):
    """Generate the name of a serialization unit test given a message name"""
    return "test_{}_serialization".format(msg_name)


class InstanceGen:
    def __init__(self, size, msgmap):
        self.size = size
        self.msgmap = msgmap

    def instancestr(self, type):
        """
        Return an instance of a given type. Do this recursively for nested types like lists and maps.
        """
        if not isinstance(type, dict):
            # A primitive type
            if cppgen.is_int(type):
                return str(randint())
            if type == "string":
                return randstring()
            if type == "bytes":
                return byteExample()
            if type == "bool":
                return random.choice(["true", "false"])
            # The type must be the name of a message
            return self.inlineStructInstanceStr(self.msgmap[type])
        if self.size == 0:
            return "{}"
        if self.size in POSSIBLE_EMPTY_SIZES:
            # Return empty values occasionally to get random empties in nested types
            # We do this for larger sizes so that we always get nested types containing 0, 1, or 2 entries.
            if random.randint(0, 1) == 0:
                return "{}"

        if "list" in type:
            return (
                "{"
                + ",".join(
                    [self.instancestr(type.list.type) for _ in range(0, self.size)]
                )
                + "}"
            )
        if "kvpair" in type:
            return (
                "{"
                + self.instancestr(type.kvpair.key)
                + ", "
                + self.instancestr(type.kvpair.value)
                + "}"
            )
        if "map" in type:
            # Maps require an initializer list of std::pairs, which themselves are represented as initializer lists.
            return (
                "{"
                + ",".join(
                    [
                        "{"
                        + self.instancestr(type.map.key)
                        + ", "
                        + self.instancestr(type.map.value)
                        + "}"
                        for _ in range(0, self.size)
                    ]
                )
                + "}"
            )
        if "optional" in type:
            return "{" + self.instancestr(type.optional.type) + "}"
        if "oneof" in type:
            return self.inlineStructInstanceStr(
                self.msgmap[random.choice(type.oneof.msg_names)]
            )
        raise CmfParseError(type.parseinfo, "Invalid field type")

    def inlineStructInstanceStr(self, msg):
        """
        Take an AST for a message and create an instance of the struct.

        This is for use during initialization inside other types.
        """
        s = "{} {{".format(msg.name)
        for field in msg.fields:
            s += self.instancestr(field.type) + ","
        s += "}"
        return s

    def structInstanceVariableStr(self, msg):
        """
        Take an AST for a message and create an instance of the struct with a named variable.
        """
        s = "{} {}{{".format(msg.name, instanceName(msg.name, self.size))
        for field in msg.fields:
            s += self.instancestr(field.type) + ","
        s += "};"
        return s


def testSerializationStr(msg_name):
    """
    Create a function that roundtrip serializes and deserializes all instances of a given message type.
    """
    s = "void {}() {{\n".format(test_name(msg_name))
    for i in range(0, MAX_SIZE):
        instance = instanceName(msg_name, i)
        s += """
  {{
    std::vector<uint8_t> output;
    Serialize(output, {});
    {} {}_computed;
    auto begin = output.cbegin();
    Deserialize(begin, {}_computed);
    assert({} == {}_computed);
  }}
""".format(
            instance, msg_name, instance, instance, instance, instance
        )
    s += "}\n"
    return s


def file_header(namespace):
    header = """/***************************************
 Autogenerated by test_cppgen.py. Do not modify.
***************************************/

#include <cassert>
#include "example.h"

"""

    if namespace:
        header += "namespace {} {{\n\n".format(namespace)
    return header


def file_trailer(namespace, ast):
    s = """
}} // namespace {}

int main() {{
""".format(
        namespace
    )
    for msg in ast.msgs:
        s += "  {}::{}();\n".format(namespace, test_name(msg.name))
    s += "}"
    return s


def generate_code_and_tests(ast):
    """ Walk concord message format(CMF) AST and generate C++ code and C++ tests"""
    namespace = "cmf::test"
    print("Generating C++ messages")
    code, msgmap = cppgen.translate(ast, namespace)
    test_code = file_header(namespace)
    print("Generating C++ message serialization tests")
    for msg in ast.msgs:
        # We generate `max_size` msg instances for tests
        gens = [InstanceGen(i, msgmap) for i in range(0, MAX_SIZE)]
        for g in gens:
            test_code += g.structInstanceVariableStr(msg) + "\n\n"
        test_code += testSerializationStr(msg.name)
    return code, test_code + file_trailer(namespace, ast)


def compile_tests():
    print("Compiling tests with g++")
    os.system("g++ -std=c++17 -o test_serialization test_serialization.cpp")


def run_tests():
    print("Running tests")
    if os.system("./test_serialization") == 0:
        print("Tests passed.")
    else:
        print("Tests failed.")


def test_serialization():
    """
    1. Generate C++ code for messages from example.cmf and write it to example.h.
    2. Generate instances of the messages as well as tests that round trip serialize and deserialize them.
    3. Compile that C++ code via g++
    4. Run the compiled C++ code as a test
    """
    try:
        with open("../grammar.ebnf") as f:
            print("Reading ../grammar.ebnf")
            grammar = f.read()
            with open("../../example.cmf") as f2:
                print("Reading ../../example.cmf")
                cmf = f2.read()
            ast, _ = cmfc.parse(grammar, cmf)
            # Uncomment to show the generated AST for debugging purposes
            # pprint(ast)
            code, tests = generate_code_and_tests(ast)
            with open("example.h", "w") as f3:
                f3.write(code)
            with open("test_serialization.cpp", "w") as f4:
                f4.write(tests)
        compile_tests()
        run_tests()

    except Exception as ex:
        print(ex)
        exit(-1)


if __name__ == "__main__":
    test_serialization()
